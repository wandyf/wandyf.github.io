---
layout: post
title: "汇编基础"
# background-image: ""
date: 2021-3-18
published: true
category: iOS
tags:
        - 汇编
---

### CPU内部构造  
![CPU内部构造](https://raw.githubusercontent.com/wandyf/wandyf.github.io/master/assets/img/2021031801.jpg)  

CPU除了有运算器、控制器，还有寄存器，寄存器的作用就是进行数据的临时存储。
- CPU的运算速度是非常快的，为了性能，CPU在内部开辟一小块临时存储区域。并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小块临时存储区域内进行。我们称这一小块区域为寄存器。 
- 对于arm64系的CPU来说，如果寄存室是x开头则表明是64位寄存器，如果是w开头则表明是32位寄存器，32位寄存器是64位寄存器的低位部分，并不是单独存在的。

- 通过改变寄存器的内容可以实现对CPU的控制
- 不同的CPU，寄存器的个数、结构是不同的

### 浮点和向量寄存器

因为浮点数的存储以及其运算的特殊性，CPU中专门提供浮点数寄存器来处理浮点数
- 浮点寄存器
  - 64位：D0 -- D31  
  - 32位：S0 -- S31  
  
现在的CPU也支持向量运算，多用于图形处理领域，支持向量计算的系统也提供了众多的向量寄存器
- 向量寄存器
  - 128位：V0 -- V31  
  
### 通用寄存器  
- 通用寄存器也称为`数据地址寄存器`，通常用来作数据计算的临时存储，做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。
- ARM64拥有32个64位的通用寄存器，`x0 ~ x30，XZR(零寄存器)`，这些通用寄存器有时也有特定用途。
  - 64位CPU可以兼容32位，所以可以只使用64位寄存器的低32位。
  - 比如w0就是x0的低32位。  

### pc寄存器 *(program counter)*
- 是指令指针寄存器，指示了CPU当前要读取指令的地址
- 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
- cpu在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
- CPU为什么将内存中的信息看做指令？
  - CPU将pc寄存器指向的内存单元的内容看做指令
  - 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc寄存器指向过  
  
### 高速缓存
CPU每执行一条指令前都需要从内存中将指令读取到CPU中并执行，而寄存器的速度相比内存读写要快很多，为了性能，CPU还集成了一个`高速缓存区域`。当程序运行时，先将要执行的指令代码以及数据复制到高速缓存中去(有操作系统完成)，CPU直接从高速缓存依次读取指令来执行。  

### bl指令
- CPU从何处执行指令是由`pc寄存器`中的内容决定的，我们可以通过改变pc寄存器的内容来控制CPU执行目标指令
- ARM64提供了一个`mov`指令（传送指令），可以用来修改大部分寄存器的值，比如：
  - `mov x0,#10`
  - `mov x1,#20`  
- 但是，mov指令并不能用于设置pc寄存器的值，ARM64没有提供这样的功能
- ARM64提供了另外的指令来修改pc寄存器的值，这些指令统称为转移指令，最简单的是`bl`指令  

# 栈
- 栈是一种具有特殊的访问方式的存储空间(后进先出,Last In Out First,`LIFO`)

### SP和FP寄存器
- sp寄存器在任意时刻会保存我们栈顶的地址
- fp寄存器,也称为x29寄存器,属于通用寄存器,但是在某些时刻我们用它来保存栈底的地址!
- 内存读写指令
  - `ldr` load register,将数据从寄存器中读出来,存到内存中
  - `str` store register,将数据从内存中读出来,存到寄存器中
- ![栈](https://raw.githubusercontent.com/wandyf/wandyf.github.io/master/assets/img/2021031802.jpg)  

