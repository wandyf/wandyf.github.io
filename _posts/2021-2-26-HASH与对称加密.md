---
layout: post
title: "HASH与对称加密"
# background-image: ""
date: 2021-2-26
published: true
category: iOS
tags:
        - HASH
---

## HASH

*`HASH`,译为`散列`，音译为`哈希`*  
把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入值的空间，不同的输入可能会散列成相同的输出，所以不可能通过散列值来确定唯一的输入值。简单来说，就是`将任意长度的消息压缩到某一固定长度的消息摘要`  

- *哈希有如下特点：*
  - 算法公开
  - 对相同数据运算，得到的结果是相同的
  - 对不同数据运算，如MD5，得到的结果默认都是128位，32个字符(*16进制*)
  - 无法进行逆运算
  - 信息摘要，用于做数据识别

- HASH算法举例
  - `MD5`  *128位，32个16进制字符*
  - `SHA1`  *160位，40个16进制字符*
  - `SHA256`  *256位，64个16进制字符*
  - 从`iOS 13.0`开始，苹果建议废弃MD5，改用`SHA256`或更安全的加密。

- 对称加密算法举例
  - `DES`  *使用较少，强度低。*
  - `3DES`  *使用3个秘钥，对原始数据进行3次加密，无意义*
  - `AES`  *高级加密标准，普遍使用。苹果钥匙串访问，美国安全局等都在使用*

- HASH算法用途
  - 用户密码的加密
  - 搜索引擎
  - 版权
  - 数字签名

- ### 用户密码的加密
  - 用户注册时，服务器直接存储密码的HASH值
  - 用户登录时，将密码以HASH形式传递给服务器
  - 由于同一对象的HASH值永远相同，现在有很多万亿条、PB级的HASH大数据库，可以通过HASH查询出原值。
  - 多次嵌套HASH或者加盐处理，也会被大数据库碰撞查询出答案(嵌套可以递归碰撞，盐会泄露)   
  - #### 更安全的HMAC加密方案
    - 使用一个秘钥进行加密，进行两次散列运算，实际开发中，秘钥来自于服务器。
    - 秘钥在注册时由服务器对应账号生成，并下发给客户端。
    - 秘钥可以用于开启设备锁，如果本地没有秘钥，向服务器索要，服务器可以判断是否下发，如果开启了设备锁，需要在原设备进行操作。
    - ##### 注意，HAMC加密方案处理后的值，在网络传输中依然可以被拦截，此时仍然不安全。
    - ##### 更安全的方案：
      - 用户登录时，将HAMC加密后的密码拼接上时间戳(截止到分钟位)再进行一次MD5加密，服务器收到请求以后，从库中去除用户的HASH密码，拼接服务器时间戳进行一次MD5加密，如果服务器结果与客户端不匹配，那么服务器就将时间戳前移一分钟，再次进行匹配，如果成功则允许登录。
      - 此种方案下，用户的HASH密码有效时间最长只有1分59秒，可以防止被网络拦截造成隐患。
- ### 搜索引擎
  - 搜索引擎的拆次搜索，每一个词的HASH相加，无论顺序，结果相同。
- ### 版权
  - 云盘类应用，上传数据时，如果与云端资源HASH值相同，再进行一系列算法(因为云端资源庞大，而HASH值可能发生碰撞，即数据不同，HASH值相同)，如文件二进制前中后各N位进行对比，文件格式对比等，如若匹配成功，可以认定为相同数据，直接完成秒传(引用统一资源)。
  - 用户上传资源时，原文件的HASH值，可以用于所有权的校验。
  - HASH值是对文件的二进制数据进行运算，修改文件名不会对HASH值有任何影响。
  - 压缩文件的HASH值会发生变化，因为文件的二进制发生了变化，复制的文件HASH不会变。
- ### 数字签名
  - 将原始数据的HASH值进行RSA加密，将加密后的HASH值与原始数据一起传递给服务器。
  - 服务器拿到数据后，对原始HASH值进行RSA解密，如果解密后的HASH值与客户端传递过来的数据的HASH值匹配，那么原始数据就是未经篡改的，否则原始数据是被篡改过的，服务器需要拒绝响应。
  - 这种用RSA加密后的HASH值，就是数字签名。



- ## 对称加密(传统加密)
  - ### 应用模式
    - `ECB`(*Electronic Code Book*): 电子密码本模式，每一块数据，独立加密。
      - 最基本的加密模式，相同的明文将永远加密成相同的密文，无初始向量，容易受到密码本重放攻击，一般情况下很少使用。
    - `CBC`(*Cipher Block Chaining*): 密码分组链接模式，使用一个秘钥和一个初始化向量对数据进行加密。
      - 明文在加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的明文加密后会形成不同的密文，这是目前最广泛的加密模式。CBC加密后的密文是上下文相关的，明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。
      - CBC可以有效保证密文的完整性，如果一个数据在传输时丢失或被篡改，后面的数据将无法进行正常解密。
  - ### 终端体验加密
    - `openssl enc -des-ecb -K 123 -nosalt -in before.txt -out after.bin`  *DES加密，ECB模式，key为123，不加盐*
    - `openssl enc -des-cbc -iv 0102030405060708 -K 123 -nosalt -in before.txt -out after.bin`  *DES加密，CBC模式，key为123，初始向量为0102030405060708，不加盐*
    - 参数增加`-d`为解密
  - ### iOS中的对称加密
    - `#import <CommonCrypto/CommonCrypto.h>`  iOS中处理加密与解密的库
    - `CCCrypt` : iOS中用于加密与解密的函数,如下:
    ```c
    CCCryptorStatus CCCrypt(
    CCOperation op,  
    CCAlgorithm alg,  
    CCOptions options,  
    const void *key,  
    size_t keyLength,  
    const void *iv,  
    const void *dataIn,  
    size_t dataInLength,  
    void *dataOut,  
    size_t dataOutAvailable,  
    size_t *dataOutMoved)  
    API_AVAILABLE(macos(10.4), ios(2.0));  
    ```


    #### *以上加密方式如果直接进行业务开发，并不安全。可以通过越狱后进行断点调试，直接捕获`CCCrypt`函数，从汇编寄存器中直接读取参数，获取明文数据。*